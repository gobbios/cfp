% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/resamplefunction.R
\name{resamplefunction}
\alias{resamplefunction}
\title{resample function}
\usage{
resamplefunction(model, dat, N, termsref = NULL, useparallel = TRUE,
  stepsalong = 11, allcores = FALSE)
}
\arguments{
\item{model}{a model fit from \code{glmmadmb}}

\item{dat}{the data set for the fit (typically a \code{data.frame})}

\item{N}{the number of (re)samples to take}

\item{termsref}{character with 'control' variables. These variables will be set to zero (numeric predictors) or their reference level (factors).}

\item{useparallel}{use the \code{doParallel} package?}

\item{stepsalong}{the resolution of steps along the range of numerical predictors}

\item{allcores}{should all available cores be used (which might slow down any activity other than R substantially). If \code{FALSE} (default), all but one core are assigned to R.}
}
\value{
a list with two items:
 \itemize{
  \item a \code{data.frame} with the predictor variables at the values for which the prediction was made
  \item a \code{matrix} with the same number of rows as the first element of the list, and \code{N} columns, i.e. the predicted values for each sample
 }
}
\description{
Resampling model estimates from glmmADMB fits
}
\details{
the function needs data sets in which columns have one dimension only (at least on the predictor side). If you get a warning or error, please check \code{unlist(lapply(<yourdata>, ncol))} to find columns that have more than one dimension. This could happen, for example, if you applied \code{scale()} to a numerical column. You could use \code{<yourdata>$mycol <- as.numeric(<yourdata>$mycol)} to fix this issue. Also, the model has to be refitted after such an operation.

In the case of glmmADMB, if the model fitting fails in one or more of the resampling runs, this would normally break the loop. The function currently uses a form of error catching that returns \code{NA} as predicted values for such cases. The function will produce a message informing you that this happend. You might want to increase \code{N} so that you actually end up with the number of valid samples intended.
}
\examples{
\dontrun{
library(glmmADMB)
set.seed(12345)
N <- 100
resp <- rnorm(n = N)
pred1 <- sample(letters[1:2], length(resp), T)
pred2 <- sample(LETTERS[3:4], length(resp), T)
pred3 <- rnorm(n = N)
ref <- sample(letters[15:20], length(resp), T)
xdata <- data.frame(resp, pred1, pred2, pred3, ref)
res <- glmmadmb(resp ~ pred1*pred2 + pred3 + (1|ref), data = xdata, family = "gaussian")
summary(res)

# predict along different values of $pred3
resamplefunction(res, xdata, N = 2)
# keep $pred3 at 0
resamplefunction(res, xdata, N = 2, termsref = "pred3")
# keep $pred2 at its reference level ("C")
resamplefunction(res, xdata, N = 2, termsref = "pred2")
# keep $pred1 at reference and $pred3 at 0
resamplefunction(res, xdata, N = 2, termsref = c("pred1", "pred3"))

epil2$subject <- factor(epil2$subject)
(fm <- glmmadmb(y ~ Base*trt + Age + Visit + (Visit|subject),
                data = epil2, family = "nbinom"))
resamplefunction(model = fm, dat = epil2, N = 3, stepsalong = 3)

library(lme4)
(fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy))
resamplefunction(model = fm1, dat = sleepstudy, N = 3, stepsalong = 3)

(gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
              data = cbpp, family = binomial))
resamplefunction(model = gm1, dat = cbpp, N = 3, stepsalong = 3)
}

}
